# Chapter 8

```{r echo=FALSE, message=FALSE, warning=FALSE, Load_packages}

library(fpp2)
library(xlsx)
library(rdatamarket)

```

2. A classic example of a non-stationary series is the daily closing IBM stock price series (data set ibmclose). Use R to plot the daily closing prices for IBM stock and the ACF and PACF. Explain how each plot shows that the series is non-stationary and should be differenced.

```{r echo=FALSE, message=FALSE, warning=FALSE, Question1}

ggtsdisplay(ibmclose)
# ACF plot shows that the autocorrelation values are bigger than critical value and decrease slowly. Also, r1 is large(near to 1) and positive. It means that the IBM stock data are non-stationary(predictable using lagged values).
# PACF plot shows that there is a strong correlation between IBM stock data and their 1 lagged values. It means that IBM stock data can be predicted by 1 lagged values and they aren't stationary.

# To get stationary data, IBM stock data need differencing. Differencing can help stabilize the mean of a time series by removing changes in the level of a time series. Therefore it will eliminate or reduce trend and seasonality and the effect can make non-staionary data stationary.

```


3. For the following series, find an appropriate Box-Cox transformation and order of differencing in order to obtain stationary data.

```{r echo=FALSE, message=FALSE, warning=FALSE, Question3}

# a. usnetelec
autoplot(usnetelec)
# It is almost linearly increasing data. It looked like that the data only need first differencing.
Box.test(diff(usnetelec), type = "Ljung-Box")
# first differenced usnetelec data can be thought of as a white noise series.
tseries::kpss.test(diff(usnetelec))
# kpss test result also shows that first differencing made the data stationary.

# b. usgdp
autoplot(usgdp)
# It is almost linearly increasing data. It looked like that the data only need first differencing.
Box.test(diff(usgdp), type = "Ljung-Box")
# first differenced usnetelec data cannot be thought of as a white noise series.
autoplot(diff(usgdp))
# There is still a trend left in the differenced data. It looked like one more differencing would be enough, but use ndiffs function to check the number of differencing needed.
ndiffs(usgdp)
# One more differencing would be enough.
autoplot(diff(diff(usgdp)))
# Plot shows that the twice differenced data is like white noise series.
Box.test(diff(diff(usgdp)), type = "Ljung-Box")
# But it couldn't pass Ljung-Box test.
ggAcf(diff(diff(usgdp)))
# There are still some autocorrelations left.
tseries::kpss.test(diff(diff(usnetelec)))
# But kpss test result shows that differencing twice was enough to make the data stationary. Therefore in usgdp data case, even if twice differencing didn't make the data like white noise series, it made the data stationary.

# c. mcopper
autoplot(mcopper)
# mcopper data have increasing trend. And they have bigger variation for bigger prices. Therefore I'll use Box-Cox transformation before differencing.
autoplot(diff(BoxCox(mcopper, BoxCox.lambda(mcopper))))
Box.test(diff(BoxCox(mcopper, BoxCox.lambda(mcopper))),
         type = "Ljung-Box")
# Plot result looked like BoxCox transformation and first differencing made the data like white noise series. But Ljung-Box test shows that it didn't.
ggAcf(diff(BoxCox(mcopper, BoxCox.lambda(mcopper))))
# There are still some autocorrelations left.
tseries::kpss.test(diff(BoxCox(mcopper, BoxCox.lambda(mcopper))))
# But kpss test result shows that differencing with Box-Cox transformation was enough to make the data stationary. In mcopper data case, even if differencing with Box-Cox transformation didn't make the data like white noise series, it made the data stationary.

# d. enplanements
autoplot(enplanements)
# enplanements data have seasonality and increasing trend even if the number fell in 2001. I think that the data need seasonal differencing, too. The variations are bigger for bigger numbers. Therefore I'll use Box-Cox transformation before differencing.
ndiffs(enplanements)
nsdiffs(enplanements)
# the data need 1 first differencing and 1 seasonal differencing.
autoplot(
  diff(
    diff(
      BoxCox(enplanements, BoxCox.lambda(enplanements)),
      lag = 12
    )
  )
)
Box.test(
  diff(
    diff(
      BoxCox(enplanements, BoxCox.lambda(enplanements)),
      lag = 12
    )
  ),
  type = "Ljung-Box"
)
# Plot result looked like BoxCox transformation and multiple differencings made the data like white noise series. But Ljung-Box test shows that it didn't.
ggAcf(
  diff(
    diff(
      BoxCox(enplanements, BoxCox.lambda(enplanements)),
      lag = 12
    )
  )
)
# There are still some autocorrelations left.
tseries::kpss.test(
  diff(
    diff(
      BoxCox(enplanements, BoxCox.lambda(enplanements)),
      lag = 12
    )
  )
)
# But kpss test result shows that differencings with Box-Cox transformation was enough to make the data stationary. In enplanements data case, even if differencings with Box-Cox transformation didn't make the data like white noise series, it made the data stationary.

# e. visitors
autoplot(visitors)
# visitors data are similar to enplanements data. They have seasonality and increasing trend. It looked like they also need Box-Cox transformation, first and seasonal differencing.
ndiffs(visitors)
nsdiffs(visitors)
# visitors data need 1 first and 1 seasonal differencing.
autoplot(
  diff(
    diff(
      BoxCox(visitors, BoxCox.lambda(visitors)),
      lag = 12
    )
  )
)
Box.test(
  diff(
    diff(
      BoxCox(visitors, BoxCox.lambda(visitors)),
      lag = 12
    )
  ),
  type = "Ljung-Box"
)
# Plot result looked like BoxCox transformation and multiple differencings made the data like white noise series. But Ljung-Box test shows that it didn't.
ggAcf(
  diff(
    diff(
      BoxCox(visitors, BoxCox.lambda(visitors)),
      lag = 12
    )
  )
)
# There are still some autocorrelations left.
tseries::kpss.test(
  diff(
    diff(
      BoxCox(visitors, BoxCox.lambda(visitors)),
      lag = 12
    )
  )
)
# But kpss test result shows that differencings with Box-Cox transformation was enough to make the data stationary. In visitors data case, even if differencings with Box-Cox transformation didn't make the data like white noise series, it made the data stationary.

```


4. For the enplanements data, write down the differences you chose above using backshift operator notation.

### the data needed 1 first difference, 1 seasonal difference after Box-Cox transformation. The model of the data can be written as ARIMA(0, 1, 0)(0, 1, 0)12 with Box-Cox transformation(lambda = -0.227).
### The model expression using backshift operator notaion B: 
### first equation : wt = (yt^(-0.227) - 1)/(-0.227)
### second equation : (1 - B)(1 - B^12)wt = et, where et is a white noise series.


5. For your retail data (from Exercise 3 in Section 2.10), find the appropriate order of differencing (after transformation if necessary) to obtain stationary data.

```{r echo=FALSE, message=FALSE, warning=FALSE, Question5}

retail <- read.xlsx("retail.xlsx",
                    startRow = 2,
                    sheetIndex = 1)

retail.ts <- ts(retail[,"A3349873A"], 
                frequency=12, 
                start=c(1982,4))

autoplot(retail.ts)
# the data have increasing trend and strong seasonality. And there are bigger variations for bigger numbers. Therefore I think that I need to use first differencing and seasonal differencing. And it would be better to do Box-Cox transformation.
ndiffs(retail.ts)
nsdiffs(retail.ts)
# I'm going to do 1 first differencing and 1 seasonal differencing.
tseries::kpss.test(
  diff(
    diff(
      BoxCox(retail.ts, BoxCox.lambda(retail.ts)),
      lag = 12
    )
  )
)
# To make retail.ts data stationary, I did Box-Cox transformation, 1 first differencing and 1 seasonal differencing.

```

6. Use R to simulate and plot some data from simple ARIMA models.

```{r echo=FALSE, message=FALSE, warning=FALSE, Question6}

# a. Use the following R code to generate data from an AR(1) model with phi1 = 0.6 and sigma^2 = 1. The process starts with y1 = 0.

y <- ts(numeric(100))
e <- rnorm(100)
for(i in 2:100){
   y[i] <- 0.6*y[i-1] + e[i]
}

# b. Produce a time plot for the series. How does the plot change as you change phi1?
ar1generator <- function(phi1){
  # generate 100 data points from an AR(1) model with input phi1.
  y <- ts(numeric(100))
  # error 'e's have variation sigma^2 as 1.
  e <- rnorm(100)
  for(i in 2:100){
    y[i] <- phi1*y[i-1] + e[i]
  }
  return(y)
}

# produce plots changing phi1 value.
autoplot(ar1generator(0.3), series = "0.3") +
  geom_line(size = 1, colour = "red") +
  autolayer(y, series = "0.6", size = 1) +
  autolayer(ar1generator(0.9), size = 1, series = "0.9") +
  ylab("AR(1) models") +
  guides(colour = guide_legend(title = "Phi1"))
# As phi increases, the variation of y increased.
    
# c. Write your own code to generate data from an MA(1) model with theta1 = 0.6 and sigma^2 = 1.
ma1generator <- function(theta1){
  # generate 100 data points from an MA(1) model with input theta1.
  y <- ts(numeric(100))
  # error 'e's have variation sigma^2 as 1.
  e <- rnorm(100)
  for(i in 2:100){
    y[i] <- theta1*e[i-1] + e[i]
  }
  return(y)
}
    
# d. Produce a time plot for the series. How does the plot change as you change theta1?
# produce plots changing theta1 value.
autoplot(ma1generator(0.3), series = "0.3") +
  geom_line(size = 1, colour = "red") +
  autolayer(y, series = "0.6", size = 1) +
  autolayer(ar1generator(0.9), size = 1, series = "0.9") +
  ylab("MA(1) models") +
  guides(colour = guide_legend(title = "Theta1"))
# As theta increases, the variation of y increased.
    
# e. Generate data from an ARMA(1,1) model with phi1 = 0.6, theta1 = 0.6 and sigma^2 = 1.
y_arima.1.0.1 <- ts(numeric(50))
e <- rnorm(50)
for(i in 2:50){
   y_arima.1.0.1[i] <- 0.6*y_arima.1.0.1[i-1] + 0.6*e[i-1] + e[i]
}
    
# f. Generate data from an AR(2) model with phi1 = ???0.8, phi2 = 0.3 and sigma^2 = 1. (Note that these parameters will give a non-stationary series.)
y_arima.2.0.0 <- ts(numeric(50))
e <- rnorm(50)
for(i in 3:50){
   y_arima.2.0.0[i] <- -0.8*y_arima.2.0.0[i-1] + 0.3*y_arima.2.0.0[i-2] + e[i]
}
    
# g. Graph the latter two series and compare them.
autoplot(y_arima.1.0.1, series = "ARMA(1, 1)") +
  autolayer(y_arima.2.0.0, series = "AR(2)") +
  ylab("y") +
  guides(colour = guide_legend(title = "Models"))

autoplot(y_arima.1.0.1)
# data from an AR(2) model increased oscillating. They are non-staionary data. But data from an ARMA(1, 1) model were stationary.

```


7. Consider the number of women murdered each year (per 100,000 standard population) in the United States. (Data set wmurders).

```{r echo=FALSE, message=FALSE, warning=FALSE, Question7}

# a. By studying appropriate graphs of the series in R, find an appropriate ARIMA(p,d,q) model for these data. 
autoplot(wmurders)
# It looked like the data don't need seasonal differencing or Box-Cox transformation.
autoplot(diff(wmurders))
# It looked like 1 more differencing would be needed to make the data stationary. Differenced data slowly go to minus infinity.
ndiffs(wmurders)
# ndiffs function shows that the data need 2 differencing.
autoplot(diff(wmurders, differences = 2))
tseries::kpss.test(diff(wmurders, differences = 2))
# twice differencing made the data stationary.
diff(wmurders, differences = 2) %>% ggtsdisplay()
# PACF is decaying. And there are significant spikes at lag 1, and 2 in the ACF, but none beyond lag 2. If the data can be modelled by ARIMA(0, 2, q) or ARIMA(p, 2, 0), I'm going to model the data by ARIMA(0, 2, 2).

# b. Should you include a constant in the model? Explain.
# ARIMA model of the data includes twice differencing. If there is a constant in the model, twice integrated contant will yield quadratic trend, which is dangerous for forecasting. Therefore I won't include a constant in the model.

# c. Write this model in terms of the backshift operator.
# (1 - B)^2*yt = (1 + theta1*B + theta2*B^2)*et

# d. Fit the model using R and examine the residuals. Is the model satisfactory?
wmurders_arima.0.2.2 <- Arima(wmurders, 
                              order = c(0, 2, 2))

checkresiduals(wmurders_arima.0.2.2)
# The residuals of the model can be thought of as white noise series. A little sorry that they aren't normally distributed. But it is satisfactory to get them.

# e. Forecast three times ahead. Check your forecasts by hand to make sure that you know how they have been calculated.
fc_wmurders_arima.0.2.2 <- forecast(
  wmurders_arima.0.2.2, h = 3
)

# forecasts by Arima function
fc_wmurders_arima.0.2.2$mean

# get forecasts by manual calculation
fc_wmurders_arima.0.2.2$model
# formula
# (1 - B)^2*yt = (1 - 1.0181*B + 0.1470*B^2)*et
# yt = 2yt-1 - yt-2 + et - 1.0181*et-1 + 0.1470*et-2
years <- length(wmurders)
e <- fc_wmurders_arima.0.2.2$residuals

fc1 <- 2*wmurders[years] - wmurders[years - 1] - 1.0181*e[years] + 0.1470*e[years - 1]

fc2 <- 2*fc1 - wmurders[years] + 0.1470*e[years]

fc3 <- 2*fc2 - fc1

# forecasts by manual calculation
c(fc1, fc2, fc3)
# the forecasts are almost similar to the ones got by Arima function.

# f. Create a plot of the series with forecasts and prediction intervals for the next three periods shown.
autoplot(fc_wmurders_arima.0.2.2)

# g. Does auto.arima give the same model you have chosen? If not, which model do you think is better?
fc_wmurders_autoarima <- forecast(
  auto.arima(wmurders), h = 3
)

# Without RMSE, all errors show that ARIMA(0, 2, 2) is better than ARIMA(1, 2, 1).
accuracy(fc_wmurders_arima.0.2.2)
accuracy(fc_wmurders_autoarima)

# try using auto.arima function with stepwise and approximation options false.
fc_wmurders_autoarima2 <- forecast(
  auto.arima(wmurders, stepwise = FALSE, approximation = FALSE), 
  h = 3
)
# It it ARIMA(0, 2, 3) model.

accuracy(fc_wmurders_autoarima2)
# In this case, some errors were better and some were worse. When the accuracy results are almost similar, it is better to choose simpler model. Therefore I'll choose ARIMA(0, 2, 2).

```


8. Consider the total international visitors to Australia (in millions) for the period 1980-2015. (Data set austa.)

```{r echo=FALSE, message=FALSE, warning=FALSE, Question8}

# a. Use auto.arima to find an appropriate ARIMA model. What model was selected. Check that the residuals look like white noise. Plot forecasts for the next 10 periods.
autoplot(austa)

fc_austa_autoarima <- forecast(
  auto.arima(austa), h = 10
)

fc_austa_autoarima$model
# ARIMA(0, 1, 1) with drift model was chosen.

checkresiduals(fc_austa_autoarima)
# The residuals are like white noise.

autoplot(fc_austa_autoarima)

# b. Plot forecasts from an ARIMA(0,1,1) model with no drift and compare these to part (a). Remove the MA term and plot again.
fc_austa_arima.0.1.1 <- forecast(
  Arima(austa, order = c(0, 1, 1)), h = 10
)

autoplot(fc_austa_arima.0.1.1)

fc_austa_arima.0.1.0 <- forecast(
  Arima(austa, order = c(0, 1, 0)), h = 10
)

autoplot(fc_austa_arima.0.1.0)
# the forecasts of both models are like the result of naive forecast. Increasing trend isn't reflected in the forecasts.

fc_austa_arima.0.1.1$upper - fc_austa_arima.0.1.0$upper
fc_austa_arima.0.1.0$lower - fc_austa_arima.0.1.1$lower
# But prediction interval of ARIMA(0, 1, 1) model was generally larger than the one of ARIMA(0, 1, 0) model. I think that it is because of one more error term in ARIMA(0, 1, 1) model.

# c. Plot forecasts from an ARIMA(2,1,3) model with drift. Remove the constant and see what happens.
fc_austa_arima.2.1.3.drift <- forecast(
  Arima(austa, order = c(2, 1, 3), include.drift = TRUE),
  h = 10
)

autoplot(fc_austa_arima.2.1.3.drift)
# The forecasts are increasing, but the speed of the increase is decreasing.

drift_austa <- fc_austa_arima.2.1.3.drift$model$coef[6]
fc_austa_arima.2.1.3.nodrift <- fc_austa_arima.2.1.3.drift$mean - drift_austa*seq_len(10)

autoplot(fc_austa_arima.2.1.3.drift) +
  autolayer(fc_austa_arima.2.1.3.nodrift)
# Without drift constant, the forecasts are unlikely.

# d. Plot forecasts from an ARIMA(0,0,1) model with a constant. Remove the MA term and plot again.
fc_austa_arima.0.0.1.const <- forecast(
  Arima(
    austa, order = c(0, 0, 1), include.constant = TRUE
    ),
  h = 10
)

autoplot(fc_austa_arima.0.0.1.const)
# the forecasts are fastly decreased to the mean of the data history.

fc_austa_arima.0.0.0.const <- forecast(
  Arima(austa, order = c(0, 0, 0), include.constant = TRUE),
  h = 10
)

autoplot(fc_austa_arima.0.0.0.const)
# All of the forecasts are the mean of the data history. It is like the result of mean method.

# e. Plot forecasts from an ARIMA(0,2,1) model with no constant.
fc_austa_arima.0.2.1 <- forecast(
  Arima(austa, order = c(0, 2, 1)),
  h = 10
)

autoplot(fc_austa_arima.0.2.1)
# the forecasts show increasing trend. PI is being larger for the farther future forecast.

```


9. For the usgdp series:
a. if necessary, find a suitable Box-Cox transformation for the data;
b. fit a suitable ARIMA model to the transformed data using auto.arima();
c. try some other plausible models by experimenting with the orders chosen;
d. choose what you think is the best model and check the residual diagnostics;
e. produce forecasts of your fitted model. Do the forecasts look reasonable?
f. compare the results with what you would obtain using ets() (with no transformation).


10. Consider austourists, the quarterly number of international tourists to Australia for the period 1999-2010. (Data set austourists.)

a. Describe the time plot.
b. What can you learn from the ACF graph?
c. What can you learn from the PACF graph?
d. Produce plots of the seasonally differenced data  
(1 ??? B^4)Yt. What model do these graphs suggest?
e. Does auto.arima give the same model that you chose? If not, which model do you think is better?
f. Write the model in terms of the backshift operator, then without using the backshift operator.


11. Consider the total net generation of electricity (in billion kilowatt hours) by the U.S. electric industry (monthly for the period January 1973 - June 2013). (Data set usmelec.) In general there are two peaks per year: in mid-summer and mid-winter.

a. Examine the 12-month moving average of this series to see what kind of trend is involved.
b. Do the data need transforming? If so, find a suitable transformation.
c. Are the data stationary? If not, find an appropriate differencing which yields stationary data.
d. Identify a couple of ARIMA models that might be useful in describing the time series. Which of your models is the best according to their AIC values?
f. Estimate the parameters of your best model and do diagnostic testing on the residuals. Do the residuals resemble white noise? If not, try to find another ARIMA model which fits better.
g. Forecast the next 15 years of electricity generation by the U.S. electric industry. Get the latest figures from https://goo.gl/WZIItv to check the accuracy of your forecasts.
h. How many years of forecasts do you think are sufficiently accurate to be usable?


12. For the mcopper data:

a. if necessary, find a suitable Box-Cox transformation for the data;
b. fit a suitable ARIMA model to the transformed data using auto.arima();
c. try some other plausible models by experimenting with the orders chosen;
d. choose what you think is the best model and check the residual diagnostics;
e. produce forecasts of your fitted model. Do the forecasts look reasonable?
f. compare the results with what you would obtain using ets() (with no transformation).


13. Choose one of the following seasonal time series: hsales, auscafe, qauselec, qcement, qgas.

a. Do the data need transforming? If so, find a suitable transformation.
b. Are the data stationary? If not, find an appropriate differencing which yields stationary data.
c. Identify a couple of ARIMA models that might be useful in describing the time series. Which of your models is the best according to their AIC values?
d. Estimate the parameters of your best model and do diagnostic testing on the residuals. Do the residuals resemble white noise? If not, try to find another ARIMA model which fits better.
e. Forecast the next 24 months of data using your preferred model.
f. Compare the forecasts obtained using ets().


14. For the same time series you used in the previous exercise, try using a non-seasonal model applied to the seasonally adjusted data obtained from STL. The stlf() function will make the calculations easy (with method="arima"). Compare the forecasts with those obtained in the previous exercise. Which do you think is the best approach?


15. For your retail time series (Exercise 5 above):

a. develop an appropriate seasonal ARIMA model;
b. compare the forecasts with those you obtained in earlier chapters;
c. Obtain up-to-date retail data from the ABS website (Cat 8501.0, Table 11), and compare your forecasts with the actual numbers. How good were the forecasts from the various models?


16. 
a. Produce a time plot of the sheep population of England and Wales from 1867-1939 (data set sheep).
b. Assume you decide to fit the following model:
yt = yt-1 + phi1(yt-1 - yt-2) + phi2(yt-2 - yt-3) + phi3(yt-3 - yt-4) + et
 
where et is a white noise series. What sort of ARIMA model is this (i.e., what are p, d, and q)?
c. By examining the ACF and PACF of the differenced data, explain why this model is appropriate.
d. The last five values of the series are given below:

Year	1935	1936	1937	1938	1939
Millions of sheep	1648	1665	1627	1791	1797
The estimated parameters are phi1 = 0.42, phi2 = -0.20, and phi3 = -0.30. Without using the forecast function, calculate forecasts for the next three years (1940-1942).
e. Now fit the model in R and obtain the forecasts using forecast. How are they different from yours? Why?

17.
a. Plot the annual bituminous coal production in the United States from 1920 to 1968 (data set ).
b. You decide to fit the following model to the series:
yt = c + phi1\*yt-1 + phi2\*yt-2 + phi3\*yt-3 + phi4\*yt-4 + et
where yt is the coal production in year t and et is a white noise series. What sort of ARIMA model is this (i.e., what are p, d, and q)?
c. Explain why this model was chosen using the ACF and PACF.
d. The last five values of the series are given below.
Year	1964	1965	1966	1967	1968
Millions of tons	467	512	534	552	545
The estimated parameters are c = 162.00, phi1 = 0.83, phi2 = -0.34, phi3 = 0.55. Without using the forecast function, calculate forecasts for the next three years (1969-1971).
e. Now fit the model in R and obtain the forecasts from the same model. How are they different from yours? Why?


18. 
a. Install the rdatamarket package in R using

  install.packages("rdatamarket")

b. Select a time series from http://datamarket.com/data/list/?q=pricing:free. Then copy its short URL and import the data using

  x <- ts(rdatamarket::dmseries("shorturl")[,1], start=??, frequency=??)

(Replace ?? with the appropriate values.)
c. Plot graphs of the data, and try to identify an appropriate ARIMA model.
d. Do residual diagnostic checking of your ARIMA model. Are the residuals white noise?
e. Use your chosen ARIMA model to forecast the next four years.
f. Now try to identify an appropriate ETS model.
g. Do residual diagnostic checking of your ETS model. Are the residuals white noise?
h. Use your chosen ETS model to forecast the next four years.
i. Which of the two models do you prefer?

### Question 1 isn't related with coding that I didn't include in this file.